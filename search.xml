<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>1605.给定行和列的和求可行矩阵</title>
    <url>/2023/03/14/1605-%E7%BB%99%E5%AE%9A%E8%A1%8C%E5%92%8C%E5%88%97%E7%9A%84%E5%92%8C%E6%B1%82%E5%8F%AF%E8%A1%8C%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>题目来自LeetCode：<a href="https://leetcode.cn/problems/find-valid-matrix-given-row-and-column-sums/">https://leetcode.cn/problems/find-valid-matrix-given-row-and-column-sums/</a></p>
<h1 id="题目（难度：中等）"><a href="#题目（难度：中等）" class="headerlink" title="题目（难度：中等）"></a>题目（难度：中等）</h1><p>给你两个非负整数数组 rowSum 和 colSum ，其中 rowSum[i] 是二维矩阵中第 i 行元素的和， colSum[j] 是第 j 列元素的和。换言之你不知道矩阵里的每个元素，但是你知道每一行和每一列的和。<br>请找到大小为 rowSum.length x colSum.length 的任意 非负整数 矩阵，且该矩阵满足 rowSum 和 colSum 的要求。<br>请你返回任意一个满足题目要求的二维矩阵，题目保证存在 至少一个 可行矩阵。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：rowSum = [3,8], colSum = [4,7]</span><br><span class="line">输出：[[3,0],</span><br><span class="line">      [1,7]]</span><br><span class="line">解释：</span><br><span class="line">第 0 行：3 + 0 = 3 == rowSum[0]</span><br><span class="line">第 1 行：1 + 7 = 8 == rowSum[1]</span><br><span class="line">第 0 列：3 + 1 = 4 == colSum[0]</span><br><span class="line">第 1 列：0 + 7 = 7 == colSum[1]</span><br><span class="line">行和列的和都满足题目要求，且所有矩阵元素都是非负的。</span><br><span class="line">另一个可行的矩阵为：[[1,2],</span><br><span class="line">                  [3,5]]</span><br><span class="line">提示：</span><br><span class="line">1 &lt;= rowSum.length, colSum.length &lt;= 500</span><br><span class="line">0 &lt;= rowSum[i], colSum[i] &lt;= 10e8</span><br><span class="line">sum(rowSum) == sum(colSum)</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>本题难处在于暴力解决的时间复杂度是毁灭性的，最坏情况矩阵是每个元素都有10^8的可能，矩阵最大可达500*500&#x3D;2.5×10^5，最坏情况可达2.5×10^13。<br>从优化暴力方法的角度入手，矩阵的每个元素res[i][j]都会小于第i行的和，第j列的和，也就是说，res[i][j] &lt;&#x3D; min(rowSum[i],colSum[j])，这样搜索范围就减小了，但这远远不够。<br>由于矩阵是可以取0的，不妨先让res[i][j]取min(rowSum[i],colSum[j])，每取完一个数，就在当前行和与当前列和上减去这个数，就算用尽当行（列）的和，当行（列）剩下的元素还能用0填补。</p>
<ol>
<li>当且只有一行的时候，第一行的和永远会大于等于各列和，所以每次取的数都会是该列的和，数组rolSum即为答案。</li>
<li>当行数大于等于2时，矩阵n×m（n &gt;&#x3D; 2, m &gt;&#x3D; 1）的第一行按照上述规则取，整行取完后，第一行的行和也就是rowSum[0]会变成0，而colSum整个数组的和会减少rowSum[0],因为不止一行，所以此时colSum这个数组的和还是大于等于0的，又因为每次取的是min(rowSum[i],colSum[j])，所以colSum数组里每个数都还是大于等于0的。即取完一行后仍然和之前的性质没有发生变化。从而使所需矩阵减少成(n - 1) × m，循环往复，最终会使得n &#x3D; 1，从而求出所需矩阵。</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] restoreMatrix(<span class="type">int</span>[] rowSum, <span class="type">int</span>[] colSum) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> rowSum.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> colSum.length;</span><br><span class="line">        <span class="type">int</span>[][] res = <span class="keyword">new</span> <span class="title class_">int</span>[row][col];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; row; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; col; j++)&#123;</span><br><span class="line">                <span class="comment">//取当前行和与列和的较小值</span></span><br><span class="line">                res[i][j] = rowSum[i] &lt; colSum[j] ? rowSum[i] : colSum[j];</span><br><span class="line">                <span class="comment">//取完在当前行和与列和中减去</span></span><br><span class="line">                rowSum[i] -= res[i][j];</span><br><span class="line">                colSum[j] -= res[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode每日一题</category>
      </categories>
      <tags>
        <tag>LeetCode每日一题</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>1012.至少有1位重复的数字</title>
    <url>/2023/03/21/1012-%E8%87%B3%E5%B0%91%E6%9C%891%E4%BD%8D%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>题目来自LeetCode：<a href="https://leetcode.cn/problems/numbers-with-repeated-digits/">https://leetcode.cn/problems/numbers-with-repeated-digits/</a></p>
<h1 id="题目（难度：困难）"><a href="#题目（难度：困难）" class="headerlink" title="题目（难度：困难）"></a>题目（难度：困难）</h1><p>给定正整数 n，返回在 [1, n] 范围内具有 <strong>至少 1 位</strong> 重复数字的正整数的个数。</p>
<p><strong>示例1</strong></p>
<blockquote>
<p><strong>输入</strong>：n &#x3D; 20<br><strong>输出</strong>：1<br><strong>解释</strong>：具有至少 1 位重复数字的正数（&lt;&#x3D; 20）只有 11 。</p>
</blockquote>
<p><strong>示例 2</strong>：</p>
<blockquote>
<p><strong>输入</strong>：n &#x3D; 100<br><strong>输出</strong>：10<br><strong>解释</strong>：具有至少 1 位重复数字的正数（&lt;&#x3D; 100）有 11，22，33，44，55，66，77，88，99 和 100 。</p>
</blockquote>
<p><strong>提示</strong>：</p>
<ul>
<li>1 &lt;&#x3D; n &lt;&#x3D; 10^9<span id="more"></span></li>
</ul>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>本题题目由于n过大，O(n)也会超出时间限制，即不能通过直接遍历得出答案，那么剩下的就是组合数学，一般组合数学的题目都可以用数位dp来解决。<strong>数位dp的介绍可以参考</strong><a href="https://oi-wiki.org/dp/number/">OI wiki</a>。<br>本题要求至少有一位重复数字的数，分情况来说的话，有2个同、3个相同…k个相同(k小于等于n的位数)，正向思考的话情况过于复杂，不妨逆向思考，求出每个数位都不相同的数f，那么至少有一位重复数字的总数为n-f，因为这两种情况互补。</p>
<p>对位数进行dfs(深度搜索)，从高位一直到低位，当搜索到最后一位，返回1或0，表示找到了或没找到一个符合条件的数字。</p>
<p><img data-src="/2023/03/21/1012-%E8%87%B3%E5%B0%91%E6%9C%891%E4%BD%8D%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/%E6%95%B0%E4%BD%8D%E9%99%90%E5%88%B6%E6%9D%A1%E4%BB%B61.png" alt="数位限制条件1"></p>
<p>每位数字都有限制条件，如图，数字456，最高位可以填0-4(0可以代表没填或则前导0), 除去最高位后，都有两种情况(以次高位5做解释)：</p>
<ul>
<li>当前一位数取到n中对应位数的值(即最高位取到4)，那么当前位只能取到n中对应位数的值(5)，即上图中的第一个范围(0-5),因为这个数不能大于n。</li>
<li>当前一位数没有取到n中对应位数的值(即最高位取到0-3)，那么当前位置没有限制(0-9)，即上图中第二个范围。</li>
</ul>
<p>解决了第一个限制条件，则要考虑现在要求每个数位上的数都不相同的数，那么当搜索到第k个数位的时候必须知道前面的数位都取了什么，所以需要标记都取过哪些数，可以用一个set集合当标记，当然更好的方法是用一个数去标记(不用耗费额外的空间和时间去判断，加上后面需要记忆化的时候更简单)，这就涉及到二进制与集合的关系：<br><img data-src="/2023/03/21/1012-%E8%87%B3%E5%B0%91%E6%9C%891%E4%BD%8D%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/%E9%9B%86%E5%90%88%E4%B8%8E%E4%BD%8D%E8%BF%90%E7%AE%97.png" alt="集合与位运算"><br>因为这个集合只记录0-9十个数，所以可以用标记数mask的二进制数的位数代表0-9，从低位开始依次表示0-9，二进制数中1代表该位代表的数在集合里，否则不在集合里，例如(101000)<sub>2</sub>，从0开始从右往左数，第一个1在第四位，也就是代表3，第二个1在第六位，代表的是5，所以整个2进制数代表集合{3,5}，那么有如下操作：</p>
<ul>
<li>添加一个数k进集合：(1 &lt;&lt; k) | mask，如上图，按添加4进集合{3,5}中为例子，1的二进制数为(0…01)<sub>2</sub>,左移4位后变成(0…010000)<sub>2</sub>,因为从低位从0开始，左移4位后，1的右面是有4个0，所以左移4位后就是在集合中代表4这个数，|(按位或操作)上mask后，mask为(111000)<sub>2</sub>，这时mask代表的集合为{3,4,5}。</li>
<li>查询一个数k是否在集合中：(mask &gt;&gt; k) &amp; 1,mask右移k位，相当让k+1位移动到最低位，&amp;(按位与操作)上1后，相当于只保留最低位的值，如果是1，则代表k在集合中，否则代表k不在集合中。</li>
<li>从集合中删除一个数k(本题没涉及删除操作)：((2^11-2) &lt;&lt; k + 2^k - 1) &amp; mask, 因为只有10个数，只需要10位表示，2^11-2的二进制是(1111111110)<sub>2</sub>,左移k位后再将左移产生的k个0填回1，即(1111011111)<sub>2</sub>，在&amp;(按位与操作)mask，即可在集合中删除k。</li>
</ul>
<p>当每一位取数的限制已经确定，那就可以递归遍历每一位数的情况，但是所有情况还是会超出时间的限制，仔细思考算12345和13345时，后面的345是重复计算的，可以用一个数组或则哈希表给他存起来，当再次需要用的时候再从里面取，而不是重新计算一次，这样就可以大大降低所需要的时间，这称为记忆化搜索。对于本题，需要记录的是当递归到第i位时，集合mask所得的结果。</p>
<p>构造递归函数f：f(int i, int mask, boolean isLimit, boolean isNum)</p>
<ul>
<li>i：当前搜索的位数</li>
<li>mask：所取过的数的集合</li>
<li>isLimit：是否受限制，也就是取0-9还是0-n中第i位的数。当为false时，代表不受限制，可以取0-9，否则就是另外一种情况</li>
<li>isNum：前面是否有填过数，当前面全0时，代表没填过数，如果前面全为0时(也就是为false)，有两种情况，当前位填0代表跳过当前位，如果是0以外则是该位不跳过。</li>
</ul>
<p>递归结束标志：当i等与n的总位数时<br>初始状态：f(0,0,true,false)，从第1位开始，由于方便记忆数组，所以下标从0开始，mask一开始空集，自然为0，第一位数是一定受限制的，一开始没填数，所以isNum也是false；</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">char</span>[] s;</span><br><span class="line">    <span class="comment">//保存计算过的结果</span></span><br><span class="line">    <span class="type">int</span>[][] dp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numDupDigitsAtMostN</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">//将数字转化成字符串，便于操作</span></span><br><span class="line">        s = String.valueOf(n).toCharArray();</span><br><span class="line">        <span class="comment">//dp[i][mask] 代表第i位选了mask集合的结果</span></span><br><span class="line">        dp = <span class="keyword">new</span> <span class="title class_">int</span>[s.length][<span class="number">1</span> &lt;&lt; <span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length; i++) &#123;</span><br><span class="line">            Arrays.fill(dp[i], -<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n - f(<span class="number">0</span>, <span class="number">0</span>, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//递归函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> mask, <span class="type">boolean</span> isLimit, <span class="type">boolean</span> isNum)</span> &#123;</span><br><span class="line">        <span class="comment">//递归结束条件</span></span><br><span class="line">        <span class="keyword">if</span>(i == s.length)&#123;</span><br><span class="line">            <span class="comment">//如果是一个合法的数则返回1</span></span><br><span class="line">            <span class="keyword">return</span> isNum ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当要计算的结果在dp中，直接用</span></span><br><span class="line">        <span class="keyword">if</span>(!isLimit &amp;&amp; isNum &amp;&amp; dp[i][mask] != -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> dp[i][mask];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//如果前面没有填过数，这是第一种情况填0，跳过当前位</span></span><br><span class="line">        <span class="keyword">if</span>(!isNum)&#123;</span><br><span class="line">            res = f(i + <span class="number">1</span>, mask, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//确定上限</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">up</span> <span class="operator">=</span> isLimit ? (s[i] - <span class="string">&#x27;0&#x27;</span>) : <span class="number">9</span>;</span><br><span class="line">        <span class="comment">//遍历可能能取的数，当isNum为false时，进入第二种情况，不跳过，也就是从1开始，</span></span><br><span class="line">        <span class="comment">//当isNum为true时，代表前面填过数，不必区分下限</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> isNum ? <span class="number">0</span> : <span class="number">1</span>; k &lt;= up; k++)&#123;</span><br><span class="line">            <span class="comment">//判断当前要取的数是否在集合里，也就是判断之前取过没有</span></span><br><span class="line">            <span class="keyword">if</span>((mask &gt;&gt; k &amp; <span class="number">1</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//mask|(1&lt;&lt;k)是将k加到集合中去，下一位受到限制的条件是当前位受限制并且当前位取得是上限</span></span><br><span class="line">                res += f(i + <span class="number">1</span>, mask | (<span class="number">1</span> &lt;&lt; k), isLimit &amp;&amp; k == up, <span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果该值没有被记录过，则记录</span></span><br><span class="line">        <span class="keyword">if</span>(dp[i][mask] == -<span class="number">1</span>)&#123;</span><br><span class="line">            dp[i][mask] = res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode每日一题</category>
      </categories>
      <tags>
        <tag>LeetCode每日一题</tag>
        <tag>数位dp</tag>
        <tag>记忆化搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>1615.最大网络秩</title>
    <url>/2023/03/15/1615-%E6%9C%80%E5%A4%A7%E7%BD%91%E7%BB%9C%E7%A7%A9/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>题目来自LeetCode：<a href="https://leetcode.cn/problems/maximal-network-rank/">https://leetcode.cn/problems/maximal-network-rank/</a></p>
<h1 id="题目（难度：中等）"><a href="#题目（难度：中等）" class="headerlink" title="题目（难度：中等）"></a>题目（难度：中等）</h1><p>n 座城市和一些连接这些城市的道路 roads 共同组成一个基础设施网络。每个 roads[i] &#x3D; [ai, bi] 都表示在城市 ai 和 bi 之间有一条双向道路。<br>两座不同城市构成的 <strong>城市对</strong> 的 <strong>网络秩</strong> 定义为：与这两座城市 <strong>直接</strong> 相连的道路总数。如果存在一条道路直接连接这两座城市，则这条道路只计算 <strong>一次</strong> 。<br>整个基础设施网络的 <strong>最大网络秩</strong> 是所有不同城市对中的 <strong>最大网络秩</strong> 。<br>给你整数 n 和数组 roads，返回整个基础设施网络的 <strong>最大网络秩</strong> 。<br><strong>示例1</strong><br><img data-src="/2023/03/15/1615-%E6%9C%80%E5%A4%A7%E7%BD%91%E7%BB%9C%E7%A7%A9/10001.png" alt="示例1"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：n = <span class="number">4</span>, roads = [[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">3</span>]]</span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：城市 <span class="number">0</span> 和 <span class="number">1</span> 的网络秩是 <span class="number">4</span>，因为共有 <span class="number">4</span> 条道路与城市 <span class="number">0</span> 或 <span class="number">1</span> 相连。位于 <span class="number">0</span> 和 <span class="number">1</span> 之间的道路只计算一次。</span><br></pre></td></tr></table></figure>
<p>提示：</p>
<ul>
<li>2 &lt;&#x3D; n &lt;&#x3D; 100</li>
<li>0 &lt;&#x3D; roads.length &lt;&#x3D; n * (n - 1) &#x2F; 2</li>
<li>roads[i].length &#x3D;&#x3D; 2</li>
<li>0 &lt;&#x3D; ai, bi &lt;&#x3D; n-1</li>
<li>ai !&#x3D; bi</li>
<li>每对城市之间 <strong>最多只有一条</strong> 道路相连<span id="more"></span></li>
</ul>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>本题考的是图的度（degree），只要找到度最大和次大的结点，即为答案。因为同一条边只算一次，如果两结点之间有边，则需要减去1。由于本题2 &lt;&#x3D; n &lt;&#x3D; 100, 直接遍历节点对即可。若n的值大于达到10^5时，即O(n^2)超出时间限制时，那就需要用贪心方法在O(n)的时间复杂度内找出度最大和次大的两个结点。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="遍历结点对O-n-2"><a href="#遍历结点对O-n-2" class="headerlink" title="遍历结点对O(n^2)"></a>遍历结点对O(n^2)</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximalNetworkRank</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] roads)</span> &#123;</span><br><span class="line">        <span class="comment">//邻接表</span></span><br><span class="line">        HashMap&lt;Integer, HashSet&lt;Integer&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//初始化邻接表</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            HashSet&lt;Integer&gt; t = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">            map.put(i, t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将E(u,v)写入邻接表</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; roads.length; i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> roads[i][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> roads[i][<span class="number">1</span>];</span><br><span class="line">            map.get(u).add(v);</span><br><span class="line">            map.get(v).add(u);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历结点对</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">                <span class="comment">//算出两结点的度和</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">cul</span> <span class="operator">=</span> map.get(i).size() + map.get(j).size();</span><br><span class="line">                <span class="comment">//判断两结点是否有边</span></span><br><span class="line">                <span class="keyword">if</span>(map.get(i).contains(j))&#123;</span><br><span class="line">                    cul--;</span><br><span class="line">                &#125;</span><br><span class="line">                max = max &gt; cul ? max : cul;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="贪心O-n"><a href="#贪心O-n" class="headerlink" title="贪心O(n)"></a>贪心O(n)</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximalNetworkRank</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] roads)</span> &#123;</span><br><span class="line">        HashMap&lt;Integer, HashSet&lt;Integer&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            HashSet&lt;Integer&gt; t = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">            map.put(i, t);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; roads.length; i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> roads[i][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> roads[i][<span class="number">1</span>];</span><br><span class="line">            map.get(u).add(v);</span><br><span class="line">            map.get(v).add(u);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">//最大数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">smax</span> <span class="operator">=</span> -<span class="number">1</span>;  <span class="comment">//次大数</span></span><br><span class="line">        List&lt;Integer&gt; maxArr = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">//最大数结点集合</span></span><br><span class="line">        List&lt;Integer&gt; smaxArr = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">//次大数结点集合</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> map.get(i).size(); <span class="comment">//当前结点度数</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            四种情况</span></span><br><span class="line"><span class="comment">            1 当前值大于最大值</span></span><br><span class="line"><span class="comment">            2 当前值等于最大值</span></span><br><span class="line"><span class="comment">            3 当前值小于最大值 大于次大值</span></span><br><span class="line"><span class="comment">            4 当前值等于次大值</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">if</span>(cur &gt; max)&#123;</span><br><span class="line">                smax = max;</span><br><span class="line">                smaxArr = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(maxArr);</span><br><span class="line">                max = cur;</span><br><span class="line">                maxArr.clear();</span><br><span class="line">                maxArr.add(i);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cur == max)&#123;</span><br><span class="line">                maxArr.add(i);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cur &gt; smax)&#123;</span><br><span class="line">                smaxArr.clear();</span><br><span class="line">                smaxArr.add(i);</span><br><span class="line">                smax = cur;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cur == smax)&#123;</span><br><span class="line">                smaxArr.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当最大值队列只有1个元素，那么答案肯定在最大值结点和次大值结点之间，只需判断结点之间是否存在边</span></span><br><span class="line">        <span class="comment">//当最大值队列不止一个元素，那么答案只会在最大值队列里，因为最大值结点中就算有边存在也是 2 * max - 1，</span></span><br><span class="line">        <span class="comment">//而最大值结点和次大值结点最大也只是 max+(max-1)=2*max-1(最大值与次大值相差1,且两结点之间没有边),</span></span><br><span class="line">        <span class="comment">//所以当最大值队列大于1时，可以不用考虑次大值队列</span></span><br><span class="line">        <span class="keyword">if</span>(maxArr.size() == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">first</span> <span class="operator">=</span> maxArr.get(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i : smaxArr)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!map.get(first).contains(i))&#123;</span><br><span class="line">                    <span class="keyword">return</span> max + smax;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> max + smax - <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> maxArr.size();</span><br><span class="line">            <span class="comment">// 如果所有边不能使最大值队列的结点互相有一条边，那么肯定存在有两个结点之间没有边</span></span><br><span class="line">            <span class="keyword">if</span>(size * (size - <span class="number">1</span>) / <span class="number">2</span> &gt; roads.length)&#123;</span><br><span class="line">                <span class="keyword">return</span> max * <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//判断最大值队列中是否有结点间存在边</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> u : maxArr)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> v : maxArr)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(u != v &amp;&amp; !map.get(u).contains(v))&#123;</span><br><span class="line">                        <span class="keyword">return</span> max * <span class="number">2</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> max * <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode每日一题</category>
      </categories>
      <tags>
        <tag>LeetCode每日一题</tag>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title>1616.分割两个字符串得到回文串</title>
    <url>/2023/03/18/1616-%E5%88%86%E5%89%B2%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%BE%97%E5%88%B0%E5%9B%9E%E6%96%87%E4%B8%B2/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>题目来自LeetCode：<a href="https://leetcode.cn/problems/split-two-strings-to-make-palindrome/">https://leetcode.cn/problems/split-two-strings-to-make-palindrome/</a></p>
<h1 id="题目（难度：中等）"><a href="#题目（难度：中等）" class="headerlink" title="题目（难度：中等）"></a>题目（难度：中等）</h1><p>给你两个字符串 a 和 b ，它们长度相同。请你选择一个下标，将两个字符串都在 <strong>相同的下标</strong> 分割开。由 a 可以得到两个字符串： aprefix 和 asuffix ，满足 a &#x3D; aprefix + asuffix ，同理，由 b 可以得到两个字符串 bprefix 和 bsuffix ，满足 b &#x3D; bprefix + bsuffix 。请你判断 aprefix + bsuffix 或者 bprefix + asuffix 能否构成回文串。<br>当你将一个字符串 s 分割成 sprefix 和 ssuffix 时， ssuffix 或者 sprefix 可以为空。比方说， s &#x3D; “abc” 那么 “” + “abc” ， “a” + “bc” ， “ab” + “c” 和 “abc” + “” 都是合法分割。<br>如果 <strong>能构成回文字符串</strong> ，那么请返回 true，否则返回 false 。<br>注意， x + y 表示连接字符串 x 和 y 。<br><strong>示例 1：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：a = <span class="string">&quot;abdef&quot;</span>, b = <span class="string">&quot;fecab&quot;</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：</span><br><span class="line">aprefix = <span class="string">&quot;abd&quot;</span>, asuffix = <span class="string">&quot;ef&quot;</span></span><br><span class="line">bprefix = <span class="string">&quot;fec&quot;</span>, bsuffix = <span class="string">&quot;ab&quot;</span></span><br><span class="line">那么 bprefix + asuffix = <span class="string">&quot;fec&quot;</span> + <span class="string">&quot;ef&quot;</span> = <span class="string">&quot;fecef&quot;</span> 是回文串。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>1 &lt;&#x3D; a.length, b.length &lt;&#x3D; 10^5</li>
<li>a.length &#x3D;&#x3D; b.length</li>
<li>a 和 b 都只包含小写英文字母<span id="more"></span></li>
</ul>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>首先，回顾单字符串如何判断其是否是回文串，只需要使用双指针，分别指向一头一尾，判断两个指针所指的字符是否相等，若相等则两个指针往中间靠，直到两个指针相遇或交叉时，之前的判断都成立，那么这个字符串则是回文串。<br>此题就是回文字符串的延申，在某处切割字符串会形成4个新的字符串：aprefix,asuffix,bprefix,bsuffix，而新字符串只能是aprefix + bsuffix或则bprefix + asuffix。那么先考虑第一种情况：aprefix + bsuffix。<br><img data-src="/2023/03/18/1616-%E5%88%86%E5%89%B2%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%BE%97%E5%88%B0%E5%9B%9E%E6%96%87%E4%B8%B2/1.png" alt="示例"><br>既然是a串前面加上b串后面，那么新串要是回文串，那就可以用判断单串的方法设两个指针，一个在a串的前头，一个在b串的后头，当判断到不相等的时候，如图所示竖线位置，进一步将字符串分成6段，因为当前只考虑第一种情况，所以3，4不需要考虑，当2，5其中一个为回文串的时候，一定能找到一个切位使得第一种情况为回文串。若2为回文串，则在2的末端作为切点，若5为回文串，则在1的结尾作为切点，若2，5都不是回文串，那么第一种情况则无法形成回文串。第二种情况，实则就是将a串和b串调换位置，方法是一致的。</p>
<h1 id="代码-O-n"><a href="#代码-O-n" class="headerlink" title="代码 O(n)"></a>代码 O(n)</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkPalindromeFormation</span><span class="params">(String a, String b)</span> &#123;</span><br><span class="line">        <span class="comment">//第一种情况和第二种情况</span></span><br><span class="line">        <span class="keyword">return</span> check(a, b) || check(b,a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(String a, String b)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> b.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(j &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//找到竖线所在的位置</span></span><br><span class="line">            <span class="keyword">if</span>(a.charAt(i) != b.charAt(j))&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//检查2，5是否为回文串</span></span><br><span class="line">        <span class="keyword">return</span> checkMid(a, i, j) || checkMid(b, i, j);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//单个字符串判断回文的方法（双指针）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkMid</span><span class="params">(String a, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a.charAt(i) != a.charAt(j))&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i &gt;= j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode每日一题</category>
      </categories>
      <tags>
        <tag>LeetCode每日一题</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>1625.执行操作后字典序最小的字符串</title>
    <url>/2023/03/19/1625-%E6%89%A7%E8%A1%8C%E6%93%8D%E4%BD%9C%E5%90%8E%E5%AD%97%E5%85%B8%E5%BA%8F%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>题目来自LeetCode：<a href="https://leetcode.cn/problems/lexicographically-smallest-string-after-applying-operations/">https://leetcode.cn/problems/lexicographically-smallest-string-after-applying-operations/</a></p>
<h1 id="题目（难度：中等）"><a href="#题目（难度：中等）" class="headerlink" title="题目（难度：中等）"></a>题目（难度：中等）</h1><p>给你一个字符串 s 以及两个整数 a 和 b 。其中，字符串 s 的长度为偶数，且仅由数字 0 到 9 组成。<br>你可以在 s 上按任意顺序多次执行下面两个操作之一：</p>
<ul>
<li>累加：将  a 加到 s 中所有下标为奇数的元素上 <strong>（下标从 0 开始）</strong>。数字一旦超过 9 就会变成 0，如此循环往复。例如，s &#x3D; “3456” 且 a &#x3D; 5，则执行此操作后 s 变成 “3951”。</li>
<li>轮转：将 s 向右轮转 b 位。例如，s &#x3D; “3456” 且 b &#x3D; 1，则执行此操作后 s 变成 “6345”。</li>
</ul>
<p>请你返回在 s 上执行上述操作任意次后可以得到的 <strong>字典序最小</strong> 的字符串。<br>如果两个字符串长度相同，那么字符串 a 字典序比字符串 b 小可以这样定义：在 a 和 b 出现不同的第一个位置上，字符串 a 中的字符出现在字母表中的时间早于 b 中的对应字符。例如，”0158” 字典序比 “0190” 小，因为不同的第一个位置是在第三个字符，显然 ‘5’ 出现在 ‘9’ 之前。<br><strong>示例 1：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;5525&quot;</span>, a = <span class="number">9</span>, b = <span class="number">2</span></span><br><span class="line">输出：<span class="string">&quot;2050&quot;</span></span><br><span class="line">解释：执行操作如下：</span><br><span class="line">初态：<span class="string">&quot;5525&quot;</span></span><br><span class="line">轮转：<span class="string">&quot;2555&quot;</span></span><br><span class="line">累加：<span class="string">&quot;2454&quot;</span></span><br><span class="line">累加：<span class="string">&quot;2353&quot;</span></span><br><span class="line">轮转：<span class="string">&quot;5323&quot;</span></span><br><span class="line">累加：<span class="string">&quot;5222&quot;</span></span><br><span class="line">累加：<span class="string">&quot;5121&quot;</span></span><br><span class="line">轮转：<span class="string">&quot;2151&quot;</span></span><br><span class="line">累加：<span class="string">&quot;2050&quot;</span>​​​​​​​​​​​​</span><br><span class="line">无法获得字典序小于 <span class="string">&quot;2050&quot;</span> 的字符串。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>2 &lt;&#x3D; s.length &lt;&#x3D; 100</li>
<li>s.length 是偶数</li>
<li>s 仅由数字 0 到 9 组成</li>
<li>1 &lt;&#x3D; a &lt;&#x3D; 9</li>
<li>1 &lt;&#x3D; b &lt;&#x3D; s.length - 1<span id="more"></span></li>
</ul>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>因为字符串s的长度是偶数，如果轮转数b是偶数，那么起始位置的字符奇偶性是不变的，也就是说怎样轮转，起始偶数下标的数一定不会加上a。轮转的话，在n次之后是一定会轮转回原串s。那么我们就可以枚举轮转的情况，直到轮转回s结束。<br><strong>那么加上一个数多少次一轮回呢？</strong><br>假设要被加数为x，加数为a，那么加了k次之后就是x + ka，因为超过9要变为0，那么加了k次之后就是(x + ka) % 10,根据取余的定理，(x + ka) % 10 -&gt; x % 10 + ka % 10，因为x小于10，最终加了k次后变成x + ka % 10，而且a &lt;&#x3D; 9,那么要变回x的最小k就是10，也就是说x加上10次a一定会变回x。<br>那么每次轮转的情况下枚举9次加a的情况，找到最小的字典序即可（当然，当b为奇数的时候，偶数下标也是可以加a的，所以枚举要加上偶数下标的）。</p>
<h1 id="代码-O-n"><a href="#代码-O-n" class="headerlink" title="代码 O(n)"></a>代码 O(n)</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">findLexSmallestString</span><span class="params">(String s, <span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="comment">//标记开始下标，如果访问到枚举过的下标，证明轮转的原来的字符串</span></span><br><span class="line">        <span class="type">boolean</span>[] vis = <span class="keyword">new</span> <span class="title class_">boolean</span>[n];</span><br><span class="line">        <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> s;</span><br><span class="line">        <span class="comment">//延长一倍的s，容易截取轮转后的新字符串</span></span><br><span class="line">        s = s + s;</span><br><span class="line">        <span class="comment">//枚举轮转</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; !vis[i]; i = (i + b) % n) &#123;</span><br><span class="line">            vis[i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">//枚举奇数下标加a</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">                <span class="comment">//如果b不是偶数则需要枚举偶数下标的数加a</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">kLimit</span> <span class="operator">=</span> b % <span class="number">2</span> == <span class="number">0</span> ? <span class="number">0</span> : <span class="number">9</span>;</span><br><span class="line">                <span class="comment">//k = 0,相当于只在枚举奇数下标，k = 9相当于偶数下标也枚举</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt;= kLimit; k++) &#123;</span><br><span class="line">                    <span class="type">char</span>[] t = s.substring(i, i + n).toCharArray();</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">1</span>; p &lt; n; p += <span class="number">2</span>) &#123;</span><br><span class="line">                        t[p] = (<span class="type">char</span>) (<span class="string">&#x27;0&#x27;</span> + (t[p] - <span class="string">&#x27;0&#x27;</span> + j * a) % <span class="number">10</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">0</span>; p &lt; n; p += <span class="number">2</span>) &#123;</span><br><span class="line">                        t[p] = (<span class="type">char</span>) (<span class="string">&#x27;0&#x27;</span> + (t[p] - <span class="string">&#x27;0&#x27;</span> + k * a) % <span class="number">10</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">tStr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(t);</span><br><span class="line">                    <span class="keyword">if</span> (tStr.compareTo(res) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                        res = tStr;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode每日一题</category>
      </categories>
      <tags>
        <tag>LeetCode每日一题</tag>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title>1630.等差子数组</title>
    <url>/2023/03/23/1630-%E7%AD%89%E5%B7%AE%E5%AD%90%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>题目来自LeetCode：<a href="https://leetcode.cn/problems/arithmetic-subarrays/">1630.等差子数组</a></p>
<h1 id="题目（难度：中等）"><a href="#题目（难度：中等）" class="headerlink" title="题目（难度：中等）"></a>题目（难度：中等）</h1><p>如果一个数列由至少两个元素组成，且每两个连续元素之间的差值都相同，那么这个序列就是 <strong>等差数列</strong> 。更正式地，数列 s 是等差数列，只需要满足：对于每个有效的 i ， s[i+1] - s[i] &#x3D;&#x3D; s[1] - s[0] 都成立。<br>例如，下面这些都是 <strong>等差数列</strong> ：</p>
<blockquote>
<p>1, 3, 5, 7, 9<br>7, 7, 7, 7<br>3, -1, -5, -9</p>
</blockquote>
<p>下面的数列 <strong>不是等差数列</strong> ：</p>
<blockquote>
<p>1, 1, 2, 5, 7</p>
</blockquote>
<p>给你一个由 n 个整数组成的数组 nums，和两个由 m 个整数组成的数组 l 和 r，后两个数组表示 m 组范围查询，其中第 i 个查询对应范围 [l[i], r[i]] 。所有数组的下标都是 <strong>从 0 开始</strong> 的。<br>返回 boolean 元素构成的答案列表 answer 。如果子数组 nums[l[i]], nums[l[i]+1], … , nums[r[i]] 可以 <strong>重新排列</strong> 形成 <strong>等差数列</strong> ，answer[i] 的值就是 true；否则answer[i] 的值就是 false 。</p>
<p><strong>示例 1</strong>：</p>
<blockquote>
<p><strong>输入</strong>：nums &#x3D; [4,6,5,9,3,7], l &#x3D; [0,0,2], r &#x3D; [2,3,5]<br><strong>输出</strong>：[true,false,true]<br><strong>解释</strong>：<br>第 0 个查询，对应子数组 [4,6,5] 。可以重新排列为等差数列 [6,5,4] 。<br>第 1 个查询，对应子数组 [4,6,5,9] 。无法重新排列形成等差数列。<br>第 2 个查询，对应子数组 [5,9,3,7] 。可以重新排列为等差数列 [3,5,7,9] 。</p>
</blockquote>
<span id="more"></span>

<p><strong>提示</strong>：</p>
<ul>
<li>n &#x3D;&#x3D; nums.length</li>
<li>m &#x3D;&#x3D; l.length</li>
<li>m &#x3D;&#x3D; r.length</li>
<li>2 &lt;&#x3D; n &lt;&#x3D; 500</li>
<li>1 &lt;&#x3D; m &lt;&#x3D; 500</li>
<li>0 &lt;&#x3D; l[i] &lt; r[i] &lt; n</li>
<li>-10^5 &lt;&#x3D; nums[i] &lt;&#x3D; 10^5</li>
</ul>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>通过分析n,m的大小，暴力解决，每次确定左右边界，把数组考出来排序，遍历，判断。时间复杂度O(mnlogn)。<br>优化：可以把排序那部分进行优化，其实判断一个数列是否为等差数列，并不需要这段序列有序，只要找到公差即可。如果一段序列是等差数列，那么每个数与最小值之间的差值肯定为公差的k倍，所以，只需遍历一遍序列，找到最大，最小值，就能计算出公差d &#x3D; (max - min) &#x2F; (长度 - 1)，最后只需再遍历一次，判断每个数与最小值的差值是否为公差的k倍即可（判断一下有没有相同的数，如果有且最大值与最小值不相等，则一定不是等差数列）。<br>时间复杂度O(mn)。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Boolean&gt; <span class="title function_">checkArithmeticSubarrays</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span>[] l, <span class="type">int</span>[] r)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> l.length;</span><br><span class="line">        List&lt;Boolean&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//遍历边界数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">t_l</span> <span class="operator">=</span> l[i];</span><br><span class="line">            <span class="type">int</span> <span class="variable">t_r</span> <span class="operator">=</span> r[i];</span><br><span class="line">            <span class="type">int</span> <span class="variable">t_len</span> <span class="operator">=</span> t_r - t_l + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//如果所求序列长度小于2，那么必定是等差数组</span></span><br><span class="line">            <span class="keyword">if</span>(t_len &lt;= <span class="number">2</span>)&#123;</span><br><span class="line">                res.add(<span class="literal">true</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//第一种方法O(mnlogn)</span></span><br><span class="line">            <span class="type">int</span>[] t = <span class="keyword">new</span> <span class="title class_">int</span>[t_len];</span><br><span class="line">            <span class="comment">//复制数组</span></span><br><span class="line">            System.arraycopy(nums, t_l, t, <span class="number">0</span>, t_len);</span><br><span class="line">            <span class="comment">//排序</span></span><br><span class="line">            Arrays.sort(t);</span><br><span class="line">            <span class="comment">//找到公差</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> t[<span class="number">1</span>] - t[<span class="number">0</span>];</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">f</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">//判断间隔是否为公差d</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">2</span>; j &lt; t_len; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(t[j] - t[j - <span class="number">1</span>] != d)&#123;</span><br><span class="line">                    f = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(f);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            //第二种方法O(mn)</span></span><br><span class="line"><span class="comment">            int max = nums[t_l], min = nums[t_l];</span></span><br><span class="line"><span class="comment">            //找到最大最小值</span></span><br><span class="line"><span class="comment">            for(int j = t_l; j &lt;= t_r; j++)&#123;</span></span><br><span class="line"><span class="comment">                max = max &gt; nums[j] ? max : nums[j];</span></span><br><span class="line"><span class="comment">                min = min &lt; nums[j] ? min : nums[j];</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            //如果最大最小值相等，则证明这个序列全都相等，自然是等差数列</span></span><br><span class="line"><span class="comment">            if(max == min)&#123;</span></span><br><span class="line"><span class="comment">                res.add(true);</span></span><br><span class="line"><span class="comment">                continue;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            //如果公差不是正数，则一定不是等差数列</span></span><br><span class="line"><span class="comment">            if((max - min) % (t_len - 1) != 0)&#123;</span></span><br><span class="line"><span class="comment">                res.add(false);</span></span><br><span class="line"><span class="comment">                continue;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            //求公差</span></span><br><span class="line"><span class="comment">            int d = (max - min) / (t_len - 1);</span></span><br><span class="line"><span class="comment">            boolean f = true;</span></span><br><span class="line"><span class="comment">            //标记数组，判断是否有重复的数</span></span><br><span class="line"><span class="comment">            boolean[] exist = new boolean[t_len];</span></span><br><span class="line"><span class="comment">            for(int j = t_l; j &lt;= t_r; j++)&#123;</span></span><br><span class="line"><span class="comment">                if((nums[j] - min) % d != 0)&#123;</span></span><br><span class="line"><span class="comment">                    f = false;</span></span><br><span class="line"><span class="comment">                    break;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">                //标记出现过的数</span></span><br><span class="line"><span class="comment">                int t = (nums[j] - min) / d;</span></span><br><span class="line"><span class="comment">                if(exist[t])&#123;</span></span><br><span class="line"><span class="comment">                    f = false;</span></span><br><span class="line"><span class="comment">                    break;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">                exist[t] = true;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            res.add(f);</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode每日一题</category>
      </categories>
      <tags>
        <tag>LeetCode每日一题</tag>
        <tag>枚举</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>2367.算术三元组的数目</title>
    <url>/2023/03/31/2367-%E7%AE%97%E6%9C%AF%E4%B8%89%E5%85%83%E7%BB%84%E7%9A%84%E6%95%B0%E7%9B%AE/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>题目来自LeetCode：<a href="https://leetcode.cn/problems/number-of-arithmetic-triplets/">2367.算术三元组的数目</a></p>
<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给你一个下标从 0 开始、<strong>严格递增</strong> 的整数数组 nums 和一个正整数 diff 。如果满足下述全部条件，则三元组 (i, j, k) 就是一个 <strong>算术三元组</strong> ：</p>
<ul>
<li>i &lt; j &lt; k ，</li>
<li>nums[j] - nums[i] &#x3D;&#x3D; diff 且</li>
<li>nums[k] - nums[j] &#x3D;&#x3D; diff</li>
</ul>
<p>返回不同 <strong>算术三元组</strong> 的数目。<br><strong>示例 1：</strong></p>
<blockquote>
<p><strong>输入</strong>：nums &#x3D; [0,1,4,6,7,10], diff &#x3D; 3<br><strong>输出</strong>：2<br><strong>解释</strong>：<br>(1, 2, 4) 是算术三元组：7 - 4 &#x3D;&#x3D; 3 且 4 - 1 &#x3D;&#x3D; 3 。<br>(2, 4, 5) 是算术三元组：10 - 7 &#x3D;&#x3D; 3 且 7 - 4 &#x3D;&#x3D; 3 。</p>
</blockquote>
<p><strong>提示</strong>：</p>
<ul>
<li>3 &lt;&#x3D; nums.length &lt;&#x3D; 200</li>
<li>0 &lt;&#x3D; nums[i] &lt;&#x3D; 200</li>
<li>1 &lt;&#x3D; diff &lt;&#x3D; 50</li>
<li>nums 严格 递增<span id="more"></span></li>
</ul>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>这题看起开就是暴力解决问题，因为数据量小。思考时间复杂度更低的算法能预防以后同样类型题目数据量大的情况。</p>
<h2 id="枚举-O-n-3-n-lt-10-3可使用"><a href="#枚举-O-n-3-n-lt-10-3可使用" class="headerlink" title="枚举 O(n^3)(n &lt; 10^3可使用)"></a>枚举 O(n^3)(n &lt; 10^3可使用)</h2><p>枚举，也就是暴力，没什么可说的，直接上代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">arithmeticTriplets</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> diff)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len - <span class="number">2</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; len - <span class="number">1</span>; j++)&#123;</span><br><span class="line">                <span class="comment">//满足第一个条件 才进入第三次循环</span></span><br><span class="line">                <span class="keyword">if</span>(nums[j] - nums[i] == diff)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> j + <span class="number">1</span>; k &lt; len; k++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(nums[k] - nums[j] == diff)&#123;</span><br><span class="line">                            res++;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二分搜索-O-nlognlogn-大约是n-lt-10-5可使用"><a href="#二分搜索-O-nlognlogn-大约是n-lt-10-5可使用" class="headerlink" title="二分搜索 O(nlognlogn)(大约是n &lt; 10^5可使用)"></a>二分搜索 O(nlognlogn)(大约是n &lt; 10^5可使用)</h2><p>在枚举的基础上优化，因为数组是严格递增的，所以可以使用两次二分，第一次寻找diff + nums[i], 即nums[j], 如果找到，继续使用二分找diff + nums[j],即nums[k]。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">arithmeticTriplets</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> diff)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            <span class="comment">//寻找diff + nums[i] </span></span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> binarySearch(nums, i + <span class="number">1</span>, len - <span class="number">1</span>, diff + nums[i]);</span><br><span class="line">            <span class="comment">//若找的到j</span></span><br><span class="line">            <span class="keyword">if</span>(j != -<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">//寻找diff + nums[j]</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> binarySearch(nums, j + <span class="number">1</span>, len - <span class="number">1</span>, diff + nums[j]);</span><br><span class="line">                <span class="comment">//若找到k，则证明有一个三元组</span></span><br><span class="line">                <span class="keyword">if</span>(k != -<span class="number">1</span>)&#123;</span><br><span class="line">                    res++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//二分搜索 在nums的[l,r]区间上寻找key</span></span><br><span class="line">    <span class="comment">//找到返回key对应的下标，找不到返回-1</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> key)</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; key)&#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; key)&#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="哈希表O-n-n-lt-10-9可使用"><a href="#哈希表O-n-n-lt-10-9可使用" class="headerlink" title="哈希表O(n) (n &lt; 10^9可使用)"></a>哈希表O(n) (n &lt; 10^9可使用)</h2><p>典型的用空间换时间，需要额外空间O(n)。i，j，k要满足nums[j] - nums[i] &#x3D; diff, nums[k] - nums[j] &#x3D; diff, 整理一下，nums[j] &#x3D; nums[i] + diff, nums[k] &#x3D; nums[i] + 2 * diff。但还需要满足i &lt; j &lt; k, 又因为数组是严格递增的且diff &gt; 0，所以在满足等式成立的情况下，i &lt; j &lt; k恒成立。即本题i &lt; j &lt; k这个条件可以忽略，也就是和顺序无关。那么，可以把数组全部存到哈希表中，遍历数组，对于每个nums[i]，在哈希表中查找是否存在nums[i] + diff和nums[i] + 2 * diff即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">arithmeticTriplets</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> diff)</span> &#123;</span><br><span class="line">        HashSet&lt;Integer&gt; hs = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            hs.add(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hs.contains(nums[i] + diff) &amp;&amp; hs.contains(nums[i] + <span class="number">2</span> * diff))&#123;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三指针O-n-n-lt-10-9可使用"><a href="#三指针O-n-n-lt-10-9可使用" class="headerlink" title="三指针O(n) (n &lt; 10^9可使用)"></a>三指针O(n) (n &lt; 10^9可使用)</h2><p>三指针能在不需要额外空间的情况下做到O(n)。维护三个指针i，j，k，当找到第一个三元组时，下一个成立的三元组i1，j1，k1，必有i1 &gt; i, j1 &gt; j, k1 &gt; k。那么只需要让他们一直往右遍历即可。<br>需要注意的时边界的判断，i &lt; n - 2, j &lt; n - 1, k &lt; n。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">arithmeticTriplets</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> diff)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">1</span>, k = <span class="number">2</span>; i &lt; len - <span class="number">2</span> &amp;&amp; j &lt; len - <span class="number">1</span> &amp;&amp; k &lt; len; i++)&#123;</span><br><span class="line">            <span class="comment">//遍历i时，确保j &gt; i</span></span><br><span class="line">            j = Math.max(j, i + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//寻找nums[j] - nums[i] &gt;= diff的j</span></span><br><span class="line">            <span class="keyword">while</span>(j &lt; len - <span class="number">1</span> &amp;&amp; nums[j] - nums[i] &lt; diff)&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//若是nums[j] - nums[i] == diff,则找到了j，否则没有j使得当前i成立，寻找下一个i。</span></span><br><span class="line">            <span class="keyword">if</span>(j &lt; n - <span class="number">1</span> &amp;&amp; nums[j] - nums[i] == diff)&#123;</span><br><span class="line">                <span class="comment">//保证k &gt; j</span></span><br><span class="line">                k = Math.max(k, j + <span class="number">1</span>);</span><br><span class="line">                <span class="comment">//寻找nums[k] - nums[j] &gt;= diff的k</span></span><br><span class="line">                <span class="keyword">while</span>(k &lt; len &amp;&amp; nums[k] - nums[j] &lt; diff)&#123;</span><br><span class="line">                    k++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//若是nums[k] - nums[j] == diff,则找到了k,即找到了三元组</span></span><br><span class="line">                <span class="comment">//否则没有k使得当前j成立，寻找下一个i。</span></span><br><span class="line">                <span class="keyword">if</span>(k &lt; len &amp;&amp; nums[k] - nums[j] == diff)&#123;</span><br><span class="line">                    res++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode每日一题</category>
      </categories>
      <tags>
        <tag>LeetCode每日一题</tag>
        <tag>枚举</tag>
        <tag>二分搜索</tag>
        <tag>哈希表</tag>
        <tag>三指针</tag>
      </tags>
  </entry>
  <entry>
    <title>2383.赢得比赛需要的最少训练时长</title>
    <url>/2023/03/13/2383-%E8%B5%A2%E5%BE%97%E6%AF%94%E8%B5%9B%E9%9C%80%E8%A6%81%E7%9A%84%E6%9C%80%E5%B0%91%E8%AE%AD%E7%BB%83%E6%97%B6%E9%95%BF/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>题目来自LeetCode：<a href="https://leetcode.cn/problems/minimum-hours-of-training-to-win-a-competition/">https://leetcode.cn/problems/minimum-hours-of-training-to-win-a-competition/</a></p>
<h1 id="题目（难度：简单）"><a href="#题目（难度：简单）" class="headerlink" title="题目（难度：简单）"></a>题目（难度：简单）</h1><p>你正在参加一场比赛，给你两个 正 整数 initialEnergy 和 initialExperience 分别表示你的初始精力和初始经验。<br>另给你两个下标从 0 开始的整数数组 energy 和 experience，长度均为 n 。<br>你将会 依次 对上 n 个对手。第 i 个对手的精力和经验分别用 energy[i] 和 experience[i] 表示。当你对上对手时，需要在经验和精力上都 严格 超过对手才能击败他们，然后在可能的情况下继续对上下一个对手。<br>击败第 i 个对手会使你的经验 增加 experience[i]，但会将你的精力 减少  energy[i] 。<br>在开始比赛前，你可以训练几个小时。每训练一个小时，你可以选择将增加经验增加 1 或者 将精力增加 1 。<br>返回击败全部 n 个对手需要训练的 最少 小时数目。</p>
<p>实例1</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：initialEnergy = 5, initialExperience = 3, energy = [1,4,3,2], experience = [2,6,3,1]</span><br><span class="line">输出：8</span><br><span class="line">解释：在 6 小时训练后，你可以将精力提高到 11 ，并且再训练 2 个小时将经验提高到 5 。</span><br><span class="line">按以下顺序与对手比赛：</span><br><span class="line">- 你的精力与经验都超过第 0 个对手，所以获胜。</span><br><span class="line">  精力变为：11 - 1 = 10 ，经验变为：5 + 2 = 7 。</span><br><span class="line">- 你的精力与经验都超过第 1 个对手，所以获胜。</span><br><span class="line">  精力变为：10 - 4 = 6 ，经验变为：7 + 6 = 13 。</span><br><span class="line">- 你的精力与经验都超过第 2 个对手，所以获胜。</span><br><span class="line">  精力变为：6 - 3 = 3 ，经验变为：13 + 3 = 16 。</span><br><span class="line">- 你的精力与经验都超过第 3 个对手，所以获胜。</span><br><span class="line">  精力变为：3 - 2 = 1 ，经验变为：16 + 1 = 17 。</span><br><span class="line">在比赛前进行了 8 小时训练，所以返回 8 。</span><br><span class="line">可以证明不存在更小的答案。</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>简单的模拟题，因为每击败一个敌人会增加经验，减少精力（击败敌人条件：精力和经验严格大于敌人），所以精力所需是敌人精力的总和加1，经验需要保证initialExperience + 第i个敌人之前的经验总和 &gt; 第i个敌人的经验即可。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minNumberOfHours</span><span class="params">(<span class="type">int</span> initialEnergy, <span class="type">int</span> initialExperience, <span class="type">int</span>[] energy, <span class="type">int</span>[] experience)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sumEnergy</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">//总精力</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">//需要训练的时长</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; energy.length; i++)&#123;</span><br><span class="line">            sumEnergy += energy[i];</span><br><span class="line">            <span class="comment">//判断initialExperience + 第i个敌人之前的经验总和 与 第i个敌人的经验</span></span><br><span class="line">            <span class="keyword">if</span>(initialExperience &lt;= experience[i])&#123; </span><br><span class="line">                <span class="comment">//少则训练到比当前敌人经验多1</span></span><br><span class="line">                res += experience[i] - initialExperience + <span class="number">1</span>;</span><br><span class="line">                initialExperience = experience[i] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            initialExperience += experience[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//若需要的总能量大于初始能量 则训练至所需能量</span></span><br><span class="line">        <span class="keyword">if</span>(sumEnergy &gt;= initialEnergy)&#123;</span><br><span class="line">            res += sumEnergy - initialEnergy + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode每日一题</category>
      </categories>
      <tags>
        <tag>LeetCode每日一题</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>2389.和有限的最长子序列</title>
    <url>/2023/03/17/2389-%E5%92%8C%E6%9C%89%E9%99%90%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>题目来自LeetCode：<a href="https://leetcode.cn/problems/longest-subsequence-with-limited-sum/">https://leetcode.cn/problems/longest-subsequence-with-limited-sum/</a></p>
<h1 id="题目（难度：简单）"><a href="#题目（难度：简单）" class="headerlink" title="题目（难度：简单）"></a>题目（难度：简单）</h1><p>给你一个长度为 n 的整数数组 nums ，和一个长度为 m 的整数数组 queries 。<br>返回一个长度为 m 的数组 answer ，其中 answer[i] 是 nums 中 元素之和小于等于 queries[i] 的 <strong>子序列</strong> 的 <strong>最大</strong> 长度  。<br><strong>子序列</strong> 是由一个数组删除某些元素（也可以不删除）但不改变剩余元素顺序得到的一个数组。<br><strong>示例1</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：nums = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">1</span>], queries = [<span class="number">3</span>,<span class="number">10</span>,<span class="number">21</span>]</span><br><span class="line">输出：[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">解释：queries 对应的 answer 如下：</span><br><span class="line">- 子序列 [<span class="number">2</span>,<span class="number">1</span>] 的和小于或等于 <span class="number">3</span> 。可以证明满足题目要求的子序列的最大长度是 <span class="number">2</span> ，所以 answer[<span class="number">0</span>] = <span class="number">2</span> 。</span><br><span class="line">- 子序列 [<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>] 的和小于或等于 <span class="number">10</span> 。可以证明满足题目要求的子序列的最大长度是 <span class="number">3</span> ，所以 answer[<span class="number">1</span>] = <span class="number">3</span> 。</span><br><span class="line">- 子序列 [<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">1</span>] 的和小于或等于 <span class="number">21</span> 。可以证明满足题目要求的子序列的最大长度是 <span class="number">4</span> ，所以 answer[<span class="number">2</span>] = <span class="number">4</span> 。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>n &#x3D;&#x3D; nums.length</li>
<li>m &#x3D;&#x3D; queries.length</li>
<li>1 &lt;&#x3D; n, m &lt;&#x3D; 1000</li>
<li>1 &lt;&#x3D; nums[i], queries[i] &lt;&#x3D; 10^6<span id="more"></span></li>
</ul>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>本题关键在读懂题目，题目要求子序列的和，根据子序列的定义，那么原数组的顺序就不重要了，要求小于等于queries[i]的最长子序列，那么只需要从小往大的挑，直到和大于queries[i]，那么前面所挑的个数即为答案。<br>可以通过求前缀和（前缀数组第i项代表原数组前i项的和）解决重复求和的过程，也就是前缀数组第i项代表长度为i的子序列和最小的值。<br>因为本题1 &lt;&#x3D; n, m &lt;&#x3D; 1000，直接在前缀数组上寻找的时间复杂度为O(nm)，也不会超出时间限制，若nm &gt; 10^9次方时，那么就需要使用二分查找在前缀数组上查找，此时的时间复杂度为O(mlog(n)).</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] answerQueries(<span class="type">int</span>[] nums, <span class="type">int</span>[] queries) &#123;</span><br><span class="line">        <span class="comment">//将原数组从小到大排序</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="type">int</span> <span class="variable">nLen</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">qLen</span> <span class="operator">=</span> queries.length;</span><br><span class="line">        <span class="comment">//数组nums的前缀和数组pre</span></span><br><span class="line">        <span class="type">int</span>[] pre = <span class="keyword">new</span> <span class="title class_">int</span>[nLen];</span><br><span class="line">        pre[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//求前缀数组的过程</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nLen; i++)&#123;</span><br><span class="line">            pre[i] = pre[i - <span class="number">1</span>] + nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[qLen];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; qLen; i++)&#123;</span><br><span class="line">            <span class="comment">//直接查找</span></span><br><span class="line">            <span class="comment">//找出大于queries[i]的pre[j],若所有数加起来也没有queries[i]大，那么原数组全部选上即为答案</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(; j &lt; nLen; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(pre[j] &gt; queries[i])&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res[i] = j;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            二分查找</span></span><br><span class="line"><span class="comment">            int l = 0;</span></span><br><span class="line"><span class="comment">            int r = nLen - 1;</span></span><br><span class="line"><span class="comment">            while(l &lt;= r)&#123;</span></span><br><span class="line"><span class="comment">                int mid = l + (r - l) / 2;</span></span><br><span class="line"><span class="comment">                if(pre[mid] &gt; queries[i])&#123;</span></span><br><span class="line"><span class="comment">                    r = mid - 1;</span></span><br><span class="line"><span class="comment">                &#125;else&#123;</span></span><br><span class="line"><span class="comment">                    l = mid + 1;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            res[i] = l;</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode每日一题</category>
      </categories>
      <tags>
        <tag>LeetCode每日一题</tag>
        <tag>贪心</tag>
        <tag>前缀和</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>2488.统计中位数为K的子数组</title>
    <url>/2023/03/16/2488-%E7%BB%9F%E8%AE%A1%E4%B8%AD%E4%BD%8D%E6%95%B0%E4%B8%BAK%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>题目来自LeetCode：<a href="https://leetcode.cn/problems/count-subarrays-with-median-k/">https://leetcode.cn/problems/count-subarrays-with-median-k/</a></p>
<h1 id="题目（难度：困难）"><a href="#题目（难度：困难）" class="headerlink" title="题目（难度：困难）"></a>题目（难度：困难）</h1><p>给你一个长度为 n 的数组 nums ，该数组由从 1 到 n 的 不同 整数组成。另给你一个正整数 k 。<br>统计并返回 nums 中的 中位数 等于 k 的非空子数组的数目。<br><strong>注意：</strong></p>
<ul>
<li>数组的中位数是按 <strong>递增</strong> 顺序排列后位于 <strong>中间</strong> 的那个元素，如果数组长度为偶数，则中位数是位于中间靠 <strong>左</strong> 的那个元素。<ul>
<li>例如，[2,3,1,4] 的中位数是 2 ，[8,4,3,5,1] 的中位数是 4 。</li>
</ul>
</li>
<li>子数组是数组中的一个连续部分。<br><strong>示例1：</strong><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：nums = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>], k = <span class="number">4</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：中位数等于 <span class="number">4</span> 的子数组有：[<span class="number">4</span>]、[<span class="number">4</span>,<span class="number">5</span>] 和 [<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>] 。</span><br></pre></td></tr></table></figure>
<strong>提示：</strong></li>
<li>n &#x3D;&#x3D; nums.length</li>
<li>1 &lt;&#x3D; n &lt;&#x3D; 10^5</li>
<li>1 &lt;&#x3D; nums[i], k &lt;&#x3D; n</li>
<li>nums 中的整数互不相同<span id="more"></span></li>
</ul>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>本题要求中位数为k的子数组，那么子数组一定包含k，所有可以k为分割点将数组nums分成左右两部分，假设k所在的下标为index，那么子数组的数目为(index + 1) * (nums.length - index + 1)。<br><img data-src="/2023/03/16/2488-%E7%BB%9F%E8%AE%A1%E4%B8%AD%E4%BD%8D%E6%95%B0%E4%B8%BAK%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/1.png" alt="子数组图解"><br>当只考虑左边，子数组有{k},{6,k}…{2,…6,k},{1,2,…6,k}共index + 1个，右边也一样，{7}…{7,…n}共(nums.length - index)个，不用右边的或则在右边挑一个与左边配合则是一个子数组，那么子数组的个数就是(index + 1) * (nums.length - index + 1)。<br>我们只需要将所有子数组都判定一次，是否以k为中位数即可，若k为中位数，那么大于k的数目等于小于k的数目，所以我们只需要判断子数组中有多少个数大于k，有多少个小于k。（题目说明当为偶数的时候中间靠左的为中位数，也就是说大于k的数目可以比小于k的数目多1）<br>最简单的是，两层循环，外层循环遍历k的右边，内层循环遍历k的左边，只要当大于k的数目减去小于k的数目等于0或者1时，则为符合题意的子数组。很遗憾的是，最坏的情况下，即k的左右两边数目相等的时候，时间复杂度来到了O(n^2),在n&#x3D;10^5时会超出时间限制。<br>那么，常用的处理方法是将任意一边的情况存进哈希表，遍历另外一边，每次判断哈希表中是否存在满足题意的情况，这样时间复杂度无论k在哪里都是O(n)。</p>
<h1 id="代码-O-n"><a href="#代码-O-n" class="headerlink" title="代码 O(n)"></a>代码 O(n)</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countSubarrays</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">//储存大于k（小于k）的个数</span></span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//找到k的位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == k)&#123;</span><br><span class="line">                index = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//当d&gt;0 d则为大于k的个数，d=0, 大于k的个数与小于k的个数相等，d&lt;0 |d|则为小于k的个数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//&#123;k&#125; 自然是符合题目的子数组</span></span><br><span class="line">        map.put(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//遍历左边</span></span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//大于k d加1， 小于k d-1</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; nums[index])&#123;</span><br><span class="line">                d++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                d--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//并且把每个情况存进哈希表</span></span><br><span class="line">            map.put(d, map.getOrDefault(d, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        d = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//不取右边任何数，符合的个数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> map.getOrDefault(<span class="number">0</span>, <span class="number">0</span>) + map.getOrDefault(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(i = index + <span class="number">1</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; nums[index])&#123;</span><br><span class="line">                d++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                d--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当左右两边大于k个数减去小于k的个数的差为0或则1的时候符合题意</span></span><br><span class="line">            res += map.getOrDefault(<span class="number">0</span> - d, <span class="number">0</span>) + map.getOrDefault(<span class="number">1</span> - d, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode每日一题</category>
      </categories>
      <tags>
        <tag>LeetCode每日一题</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
</search>
