<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>1605.给定行和列的和求可行矩阵</title>
    <url>/2023/03/14/1605-%E7%BB%99%E5%AE%9A%E8%A1%8C%E5%92%8C%E5%88%97%E7%9A%84%E5%92%8C%E6%B1%82%E5%8F%AF%E8%A1%8C%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>题目来自LeetCode：<a href="https://leetcode.cn/problems/find-valid-matrix-given-row-and-column-sums/">https://leetcode.cn/problems/find-valid-matrix-given-row-and-column-sums/</a></p>
<h1 id="题目（难度：中等）"><a href="#题目（难度：中等）" class="headerlink" title="题目（难度：中等）"></a>题目（难度：中等）</h1><p>给你两个非负整数数组 rowSum 和 colSum ，其中 rowSum[i] 是二维矩阵中第 i 行元素的和， colSum[j] 是第 j 列元素的和。换言之你不知道矩阵里的每个元素，但是你知道每一行和每一列的和。<br>请找到大小为 rowSum.length x colSum.length 的任意 非负整数 矩阵，且该矩阵满足 rowSum 和 colSum 的要求。<br>请你返回任意一个满足题目要求的二维矩阵，题目保证存在 至少一个 可行矩阵。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：rowSum = [3,8], colSum = [4,7]</span><br><span class="line">输出：[[3,0],</span><br><span class="line">      [1,7]]</span><br><span class="line">解释：</span><br><span class="line">第 0 行：3 + 0 = 3 == rowSum[0]</span><br><span class="line">第 1 行：1 + 7 = 8 == rowSum[1]</span><br><span class="line">第 0 列：3 + 1 = 4 == colSum[0]</span><br><span class="line">第 1 列：0 + 7 = 7 == colSum[1]</span><br><span class="line">行和列的和都满足题目要求，且所有矩阵元素都是非负的。</span><br><span class="line">另一个可行的矩阵为：[[1,2],</span><br><span class="line">                  [3,5]]</span><br><span class="line">提示：</span><br><span class="line">1 &lt;= rowSum.length, colSum.length &lt;= 500</span><br><span class="line">0 &lt;= rowSum[i], colSum[i] &lt;= 10e8</span><br><span class="line">sum(rowSum) == sum(colSum)</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>本题难处在于暴力解决的时间复杂度是毁灭性的，最坏情况矩阵是每个元素都有10^8的可能，矩阵最大可达500*500&#x3D;2.5×10^5，最坏情况可达2.5×10^13。<br>从优化暴力方法的角度入手，矩阵的每个元素res[i][j]都会小于第i行的和，第j列的和，也就是说，res[i][j] &lt;&#x3D; min(rowSum[i],colSum[j])，这样搜索范围就减小了，但这远远不够。<br>由于矩阵是可以取0的，不妨先让res[i][j]取min(rowSum[i],colSum[j])，每取完一个数，就在当前行和与当前列和上减去这个数，就算用尽当行（列）的和，当行（列）剩下的元素还能用0填补。</p>
<ol>
<li>当且只有一行的时候，第一行的和永远会大于等于各列和，所以每次取的数都会是该列的和，数组rolSum即为答案。</li>
<li>当行数大于等于2时，矩阵n×m（n &gt;&#x3D; 2, m &gt;&#x3D; 1）的第一行按照上述规则取，整行取完后，第一行的行和也就是rowSum[0]会变成0，而colSum整个数组的和会减少rowSum[0],因为不止一行，所以此时colSum这个数组的和还是大于等于0的，又因为每次取的是min(rowSum[i],colSum[j])，所以colSum数组里每个数都还是大于等于0的。即取完一行后仍然和之前的性质没有发生变化。从而使所需矩阵减少成(n - 1) × m，循环往复，最终会使得n &#x3D; 1，从而求出所需矩阵。</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] restoreMatrix(<span class="type">int</span>[] rowSum, <span class="type">int</span>[] colSum) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> rowSum.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> colSum.length;</span><br><span class="line">        <span class="type">int</span>[][] res = <span class="keyword">new</span> <span class="title class_">int</span>[row][col];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; row; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; col; j++)&#123;</span><br><span class="line">                <span class="comment">//取当前行和与列和的较小值</span></span><br><span class="line">                res[i][j] = rowSum[i] &lt; colSum[j] ? rowSum[i] : colSum[j];</span><br><span class="line">                <span class="comment">//取完在当前行和与列和中减去</span></span><br><span class="line">                rowSum[i] -= res[i][j];</span><br><span class="line">                colSum[j] -= res[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode每日一题</category>
      </categories>
      <tags>
        <tag>LeetCode每日一题</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>1615.最大网络秩</title>
    <url>/2023/03/15/1615-%E6%9C%80%E5%A4%A7%E7%BD%91%E7%BB%9C%E7%A7%A9/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>题目来自LeetCode：<a href="https://leetcode.cn/problems/maximal-network-rank/">https://leetcode.cn/problems/maximal-network-rank/</a></p>
<h1 id="题目（难度：中等）"><a href="#题目（难度：中等）" class="headerlink" title="题目（难度：中等）"></a>题目（难度：中等）</h1><p>n 座城市和一些连接这些城市的道路 roads 共同组成一个基础设施网络。每个 roads[i] &#x3D; [ai, bi] 都表示在城市 ai 和 bi 之间有一条双向道路。<br>两座不同城市构成的 <strong>城市对</strong> 的 <strong>网络秩</strong> 定义为：与这两座城市 <strong>直接</strong> 相连的道路总数。如果存在一条道路直接连接这两座城市，则这条道路只计算 <strong>一次</strong> 。<br>整个基础设施网络的 <strong>最大网络秩</strong> 是所有不同城市对中的 <strong>最大网络秩</strong> 。<br>给你整数 n 和数组 roads，返回整个基础设施网络的 <strong>最大网络秩</strong> 。<br><strong>示例1</strong><br><img data-src="/2023/03/15/1615-%E6%9C%80%E5%A4%A7%E7%BD%91%E7%BB%9C%E7%A7%A9/10001.png" alt="示例1"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：n = <span class="number">4</span>, roads = [[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">3</span>]]</span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：城市 <span class="number">0</span> 和 <span class="number">1</span> 的网络秩是 <span class="number">4</span>，因为共有 <span class="number">4</span> 条道路与城市 <span class="number">0</span> 或 <span class="number">1</span> 相连。位于 <span class="number">0</span> 和 <span class="number">1</span> 之间的道路只计算一次。</span><br></pre></td></tr></table></figure>
<p>提示：</p>
<ul>
<li>2 &lt;&#x3D; n &lt;&#x3D; 100</li>
<li>0 &lt;&#x3D; roads.length &lt;&#x3D; n * (n - 1) &#x2F; 2</li>
<li>roads[i].length &#x3D;&#x3D; 2</li>
<li>0 &lt;&#x3D; ai, bi &lt;&#x3D; n-1</li>
<li>ai !&#x3D; bi</li>
<li>每对城市之间 <strong>最多只有一条</strong> 道路相连<span id="more"></span></li>
</ul>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>本题考的是图的度（degree），只要找到度最大和次大的结点，即为答案。因为同一条边只算一次，如果两结点之间有边，则需要减去1。由于本题2 &lt;&#x3D; n &lt;&#x3D; 100, 直接遍历节点对即可。若n的值大于达到10^5时，即O(n^2)超出时间限制时，那就需要用贪心方法在O(n)的时间复杂度内找出度最大和次大的两个结点。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="遍历结点对O-n-2"><a href="#遍历结点对O-n-2" class="headerlink" title="遍历结点对O(n^2)"></a>遍历结点对O(n^2)</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximalNetworkRank</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] roads)</span> &#123;</span><br><span class="line">        <span class="comment">//邻接表</span></span><br><span class="line">        HashMap&lt;Integer, HashSet&lt;Integer&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//初始化邻接表</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            HashSet&lt;Integer&gt; t = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">            map.put(i, t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将E(u,v)写入邻接表</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; roads.length; i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> roads[i][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> roads[i][<span class="number">1</span>];</span><br><span class="line">            map.get(u).add(v);</span><br><span class="line">            map.get(v).add(u);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历结点对</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">                <span class="comment">//算出两结点的度和</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">cul</span> <span class="operator">=</span> map.get(i).size() + map.get(j).size();</span><br><span class="line">                <span class="comment">//判断两结点是否有边</span></span><br><span class="line">                <span class="keyword">if</span>(map.get(i).contains(j))&#123;</span><br><span class="line">                    cul--;</span><br><span class="line">                &#125;</span><br><span class="line">                max = max &gt; cul ? max : cul;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="贪心O-n"><a href="#贪心O-n" class="headerlink" title="贪心O(n)"></a>贪心O(n)</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximalNetworkRank</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] roads)</span> &#123;</span><br><span class="line">        HashMap&lt;Integer, HashSet&lt;Integer&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            HashSet&lt;Integer&gt; t = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">            map.put(i, t);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; roads.length; i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> roads[i][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> roads[i][<span class="number">1</span>];</span><br><span class="line">            map.get(u).add(v);</span><br><span class="line">            map.get(v).add(u);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">//最大数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">smax</span> <span class="operator">=</span> -<span class="number">1</span>;  <span class="comment">//次大数</span></span><br><span class="line">        List&lt;Integer&gt; maxArr = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">//最大数结点集合</span></span><br><span class="line">        List&lt;Integer&gt; smaxArr = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">//次大数结点集合</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> map.get(i).size(); <span class="comment">//当前结点度数</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            四种情况</span></span><br><span class="line"><span class="comment">            1 当前值大于最大值</span></span><br><span class="line"><span class="comment">            2 当前值等于最大值</span></span><br><span class="line"><span class="comment">            3 当前值小于最大值 大于次大值</span></span><br><span class="line"><span class="comment">            4 当前值等于次大值</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">if</span>(cur &gt; max)&#123;</span><br><span class="line">                smax = max;</span><br><span class="line">                smaxArr = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(maxArr);</span><br><span class="line">                max = cur;</span><br><span class="line">                maxArr.clear();</span><br><span class="line">                maxArr.add(i);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cur == max)&#123;</span><br><span class="line">                maxArr.add(i);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cur &gt; smax)&#123;</span><br><span class="line">                smaxArr.clear();</span><br><span class="line">                smaxArr.add(i);</span><br><span class="line">                smax = cur;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cur == smax)&#123;</span><br><span class="line">                smaxArr.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当最大值队列只有1个元素，那么答案肯定在最大值结点和次大值结点之间，只需判断结点之间是否存在边</span></span><br><span class="line">        <span class="comment">//当最大值队列不止一个元素，那么答案只会在最大值队列里，因为最大值结点中就算有边存在也是 2 * max - 1，</span></span><br><span class="line">        <span class="comment">//而最大值结点和次大值结点最大也只是 max+(max-1)=2*max-1(最大值与次大值相差1,且两结点之间没有边),</span></span><br><span class="line">        <span class="comment">//所以当最大值队列大于1时，可以不用考虑次大值队列</span></span><br><span class="line">        <span class="keyword">if</span>(maxArr.size() == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">first</span> <span class="operator">=</span> maxArr.get(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i : smaxArr)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!map.get(first).contains(i))&#123;</span><br><span class="line">                    <span class="keyword">return</span> max + smax;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> max + smax - <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> maxArr.size();</span><br><span class="line">            <span class="comment">// 如果所有边不能使最大值队列的结点互相有一条边，那么肯定存在有两个结点之间没有边</span></span><br><span class="line">            <span class="keyword">if</span>(size * (size - <span class="number">1</span>) / <span class="number">2</span> &gt; roads.length)&#123;</span><br><span class="line">                <span class="keyword">return</span> max * <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//判断最大值队列中是否有结点间存在边</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> u : maxArr)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> v : maxArr)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(u != v &amp;&amp; !map.get(u).contains(v))&#123;</span><br><span class="line">                        <span class="keyword">return</span> max * <span class="number">2</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> max * <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode每日一题</category>
      </categories>
      <tags>
        <tag>LeetCode每日一题</tag>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title>1616.分割两个字符串得到回文串</title>
    <url>/2023/03/18/1616-%E5%88%86%E5%89%B2%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%BE%97%E5%88%B0%E5%9B%9E%E6%96%87%E4%B8%B2/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>题目来自LeetCode：<a href="https://leetcode.cn/problems/split-two-strings-to-make-palindrome/">https://leetcode.cn/problems/split-two-strings-to-make-palindrome/</a></p>
<h1 id="题目（难度：中等）"><a href="#题目（难度：中等）" class="headerlink" title="题目（难度：中等）"></a>题目（难度：中等）</h1><p>给你两个字符串 a 和 b ，它们长度相同。请你选择一个下标，将两个字符串都在 <strong>相同的下标</strong> 分割开。由 a 可以得到两个字符串： aprefix 和 asuffix ，满足 a &#x3D; aprefix + asuffix ，同理，由 b 可以得到两个字符串 bprefix 和 bsuffix ，满足 b &#x3D; bprefix + bsuffix 。请你判断 aprefix + bsuffix 或者 bprefix + asuffix 能否构成回文串。<br>当你将一个字符串 s 分割成 sprefix 和 ssuffix 时， ssuffix 或者 sprefix 可以为空。比方说， s &#x3D; “abc” 那么 “” + “abc” ， “a” + “bc” ， “ab” + “c” 和 “abc” + “” 都是合法分割。<br>如果 <strong>能构成回文字符串</strong> ，那么请返回 true，否则返回 false 。<br>注意， x + y 表示连接字符串 x 和 y 。<br><strong>示例 1：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：a = <span class="string">&quot;abdef&quot;</span>, b = <span class="string">&quot;fecab&quot;</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：</span><br><span class="line">aprefix = <span class="string">&quot;abd&quot;</span>, asuffix = <span class="string">&quot;ef&quot;</span></span><br><span class="line">bprefix = <span class="string">&quot;fec&quot;</span>, bsuffix = <span class="string">&quot;ab&quot;</span></span><br><span class="line">那么 bprefix + asuffix = <span class="string">&quot;fec&quot;</span> + <span class="string">&quot;ef&quot;</span> = <span class="string">&quot;fecef&quot;</span> 是回文串。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>1 &lt;&#x3D; a.length, b.length &lt;&#x3D; 10^5</li>
<li>a.length &#x3D;&#x3D; b.length</li>
<li>a 和 b 都只包含小写英文字母<span id="more"></span></li>
</ul>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>首先，回顾单字符串如何判断其是否是回文串，只需要使用双指针，分别指向一头一尾，判断两个指针所指的字符是否相等，若相等则两个指针往中间靠，直到两个指针相遇或交叉时，之前的判断都成立，那么这个字符串则是回文串。<br>此题就是回文字符串的延申，在某处切割字符串会形成4个新的字符串：aprefix,asuffix,bprefix,bsuffix，而新字符串只能是aprefix + bsuffix或则bprefix + asuffix。那么先考虑第一种情况：aprefix + bsuffix。<br><img data-src="/2023/03/18/1616-%E5%88%86%E5%89%B2%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%BE%97%E5%88%B0%E5%9B%9E%E6%96%87%E4%B8%B2/1.png" alt="示例"><br>既然是a串前面加上b串后面，那么新串要是回文串，那就可以用判断单串的方法设两个指针，一个在a串的前头，一个在b串的后头，当判断到不相等的时候，如图所示竖线位置，进一步将字符串分成6段，因为当前只考虑第一种情况，所以3，4不需要考虑，当2，5其中一个为回文串的时候，一定能找到一个切位使得第一种情况为回文串。若2为回文串，则在2的末端作为切点，若5为回文串，则在1的结尾作为切点，若2，5都不是回文串，那么第一种情况则无法形成回文串。第二种情况，实则就是将a串和b串调换位置，方法是一致的。</p>
<h1 id="代码-O-n"><a href="#代码-O-n" class="headerlink" title="代码 O(n)"></a>代码 O(n)</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkPalindromeFormation</span><span class="params">(String a, String b)</span> &#123;</span><br><span class="line">        <span class="comment">//第一种情况和第二种情况</span></span><br><span class="line">        <span class="keyword">return</span> check(a, b) || check(b,a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(String a, String b)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> b.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(j &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//找到竖线所在的位置</span></span><br><span class="line">            <span class="keyword">if</span>(a.charAt(i) != b.charAt(j))&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//检查2，5是否为回文串</span></span><br><span class="line">        <span class="keyword">return</span> checkMid(a, i, j) || checkMid(b, i, j);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//单个字符串判断回文的方法（双指针）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkMid</span><span class="params">(String a, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a.charAt(i) != a.charAt(j))&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i &gt;= j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode每日一题</category>
      </categories>
      <tags>
        <tag>LeetCode每日一题</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>2383.赢得比赛需要的最少训练时长</title>
    <url>/2023/03/13/2383-%E8%B5%A2%E5%BE%97%E6%AF%94%E8%B5%9B%E9%9C%80%E8%A6%81%E7%9A%84%E6%9C%80%E5%B0%91%E8%AE%AD%E7%BB%83%E6%97%B6%E9%95%BF/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>题目来自LeetCode：<a href="https://leetcode.cn/problems/minimum-hours-of-training-to-win-a-competition/">https://leetcode.cn/problems/minimum-hours-of-training-to-win-a-competition/</a></p>
<h1 id="题目（难度：简单）"><a href="#题目（难度：简单）" class="headerlink" title="题目（难度：简单）"></a>题目（难度：简单）</h1><p>你正在参加一场比赛，给你两个 正 整数 initialEnergy 和 initialExperience 分别表示你的初始精力和初始经验。<br>另给你两个下标从 0 开始的整数数组 energy 和 experience，长度均为 n 。<br>你将会 依次 对上 n 个对手。第 i 个对手的精力和经验分别用 energy[i] 和 experience[i] 表示。当你对上对手时，需要在经验和精力上都 严格 超过对手才能击败他们，然后在可能的情况下继续对上下一个对手。<br>击败第 i 个对手会使你的经验 增加 experience[i]，但会将你的精力 减少  energy[i] 。<br>在开始比赛前，你可以训练几个小时。每训练一个小时，你可以选择将增加经验增加 1 或者 将精力增加 1 。<br>返回击败全部 n 个对手需要训练的 最少 小时数目。</p>
<p>实例1</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：initialEnergy = 5, initialExperience = 3, energy = [1,4,3,2], experience = [2,6,3,1]</span><br><span class="line">输出：8</span><br><span class="line">解释：在 6 小时训练后，你可以将精力提高到 11 ，并且再训练 2 个小时将经验提高到 5 。</span><br><span class="line">按以下顺序与对手比赛：</span><br><span class="line">- 你的精力与经验都超过第 0 个对手，所以获胜。</span><br><span class="line">  精力变为：11 - 1 = 10 ，经验变为：5 + 2 = 7 。</span><br><span class="line">- 你的精力与经验都超过第 1 个对手，所以获胜。</span><br><span class="line">  精力变为：10 - 4 = 6 ，经验变为：7 + 6 = 13 。</span><br><span class="line">- 你的精力与经验都超过第 2 个对手，所以获胜。</span><br><span class="line">  精力变为：6 - 3 = 3 ，经验变为：13 + 3 = 16 。</span><br><span class="line">- 你的精力与经验都超过第 3 个对手，所以获胜。</span><br><span class="line">  精力变为：3 - 2 = 1 ，经验变为：16 + 1 = 17 。</span><br><span class="line">在比赛前进行了 8 小时训练，所以返回 8 。</span><br><span class="line">可以证明不存在更小的答案。</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>简单的模拟题，因为每击败一个敌人会增加经验，减少精力（击败敌人条件：精力和经验严格大于敌人），所以精力所需是敌人精力的总和加1，经验需要保证initialExperience + 第i个敌人之前的经验总和 &gt; 第i个敌人的经验即可。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minNumberOfHours</span><span class="params">(<span class="type">int</span> initialEnergy, <span class="type">int</span> initialExperience, <span class="type">int</span>[] energy, <span class="type">int</span>[] experience)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sumEnergy</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">//总精力</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">//需要训练的时长</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; energy.length; i++)&#123;</span><br><span class="line">            sumEnergy += energy[i];</span><br><span class="line">            <span class="comment">//判断initialExperience + 第i个敌人之前的经验总和 与 第i个敌人的经验</span></span><br><span class="line">            <span class="keyword">if</span>(initialExperience &lt;= experience[i])&#123; </span><br><span class="line">                <span class="comment">//少则训练到比当前敌人经验多1</span></span><br><span class="line">                res += experience[i] - initialExperience + <span class="number">1</span>;</span><br><span class="line">                initialExperience = experience[i] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            initialExperience += experience[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//若需要的总能量大于初始能量 则训练至所需能量</span></span><br><span class="line">        <span class="keyword">if</span>(sumEnergy &gt;= initialEnergy)&#123;</span><br><span class="line">            res += sumEnergy - initialEnergy + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode每日一题</category>
      </categories>
      <tags>
        <tag>LeetCode每日一题</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>2389.和有限的最长子序列</title>
    <url>/2023/03/17/2389-%E5%92%8C%E6%9C%89%E9%99%90%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>题目来自LeetCode：<a href="https://leetcode.cn/problems/longest-subsequence-with-limited-sum/">https://leetcode.cn/problems/longest-subsequence-with-limited-sum/</a></p>
<h1 id="题目（难度：简单）"><a href="#题目（难度：简单）" class="headerlink" title="题目（难度：简单）"></a>题目（难度：简单）</h1><p>给你一个长度为 n 的整数数组 nums ，和一个长度为 m 的整数数组 queries 。<br>返回一个长度为 m 的数组 answer ，其中 answer[i] 是 nums 中 元素之和小于等于 queries[i] 的 <strong>子序列</strong> 的 <strong>最大</strong> 长度  。<br><strong>子序列</strong> 是由一个数组删除某些元素（也可以不删除）但不改变剩余元素顺序得到的一个数组。<br><strong>示例1</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：nums = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">1</span>], queries = [<span class="number">3</span>,<span class="number">10</span>,<span class="number">21</span>]</span><br><span class="line">输出：[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">解释：queries 对应的 answer 如下：</span><br><span class="line">- 子序列 [<span class="number">2</span>,<span class="number">1</span>] 的和小于或等于 <span class="number">3</span> 。可以证明满足题目要求的子序列的最大长度是 <span class="number">2</span> ，所以 answer[<span class="number">0</span>] = <span class="number">2</span> 。</span><br><span class="line">- 子序列 [<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>] 的和小于或等于 <span class="number">10</span> 。可以证明满足题目要求的子序列的最大长度是 <span class="number">3</span> ，所以 answer[<span class="number">1</span>] = <span class="number">3</span> 。</span><br><span class="line">- 子序列 [<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">1</span>] 的和小于或等于 <span class="number">21</span> 。可以证明满足题目要求的子序列的最大长度是 <span class="number">4</span> ，所以 answer[<span class="number">2</span>] = <span class="number">4</span> 。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>n &#x3D;&#x3D; nums.length</li>
<li>m &#x3D;&#x3D; queries.length</li>
<li>1 &lt;&#x3D; n, m &lt;&#x3D; 1000</li>
<li>1 &lt;&#x3D; nums[i], queries[i] &lt;&#x3D; 10^6<span id="more"></span></li>
</ul>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>本题关键在读懂题目，题目要求子序列的和，根据子序列的定义，那么原数组的顺序就不重要了，要求小于等于queries[i]的最长子序列，那么只需要从小往大的挑，直到和大于queries[i]，那么前面所挑的个数即为答案。<br>可以通过求前缀和（前缀数组第i项代表原数组前i项的和）解决重复求和的过程，也就是前缀数组第i项代表长度为i的子序列和最小的值。<br>因为本题1 &lt;&#x3D; n, m &lt;&#x3D; 1000，直接在前缀数组上寻找的时间复杂度为O(nm)，也不会超出时间限制，若nm &gt; 10^9次方时，那么就需要使用二分查找在前缀数组上查找，此时的时间复杂度为O(mlog(n)).</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] answerQueries(<span class="type">int</span>[] nums, <span class="type">int</span>[] queries) &#123;</span><br><span class="line">        <span class="comment">//将原数组从小到大排序</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="type">int</span> <span class="variable">nLen</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">qLen</span> <span class="operator">=</span> queries.length;</span><br><span class="line">        <span class="comment">//数组nums的前缀和数组pre</span></span><br><span class="line">        <span class="type">int</span>[] pre = <span class="keyword">new</span> <span class="title class_">int</span>[nLen];</span><br><span class="line">        pre[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//求前缀数组的过程</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nLen; i++)&#123;</span><br><span class="line">            pre[i] = pre[i - <span class="number">1</span>] + nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[qLen];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; qLen; i++)&#123;</span><br><span class="line">            <span class="comment">//直接查找</span></span><br><span class="line">            <span class="comment">//找出大于queries[i]的pre[j],若所有数加起来也没有queries[i]大，那么原数组全部选上即为答案</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(; j &lt; nLen; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(pre[j] &gt; queries[i])&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res[i] = j;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            二分查找</span></span><br><span class="line"><span class="comment">            int l = 0;</span></span><br><span class="line"><span class="comment">            int r = nLen - 1;</span></span><br><span class="line"><span class="comment">            while(l &lt;= r)&#123;</span></span><br><span class="line"><span class="comment">                int mid = l + (r - l) / 2;</span></span><br><span class="line"><span class="comment">                if(pre[mid] &gt; queries[i])&#123;</span></span><br><span class="line"><span class="comment">                    r = mid - 1;</span></span><br><span class="line"><span class="comment">                &#125;else&#123;</span></span><br><span class="line"><span class="comment">                    l = mid + 1;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            res[i] = l;</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode每日一题</category>
      </categories>
      <tags>
        <tag>LeetCode每日一题</tag>
        <tag>贪心</tag>
        <tag>前缀和</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>2488.统计中位数为K的子数组</title>
    <url>/2023/03/16/2488-%E7%BB%9F%E8%AE%A1%E4%B8%AD%E4%BD%8D%E6%95%B0%E4%B8%BAK%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>题目来自LeetCode：<a href="https://leetcode.cn/problems/count-subarrays-with-median-k/">https://leetcode.cn/problems/count-subarrays-with-median-k/</a></p>
<h1 id="题目（难度：困难）"><a href="#题目（难度：困难）" class="headerlink" title="题目（难度：困难）"></a>题目（难度：困难）</h1><p>给你一个长度为 n 的数组 nums ，该数组由从 1 到 n 的 不同 整数组成。另给你一个正整数 k 。<br>统计并返回 nums 中的 中位数 等于 k 的非空子数组的数目。<br><strong>注意：</strong></p>
<ul>
<li>数组的中位数是按 <strong>递增</strong> 顺序排列后位于 <strong>中间</strong> 的那个元素，如果数组长度为偶数，则中位数是位于中间靠 <strong>左</strong> 的那个元素。<ul>
<li>例如，[2,3,1,4] 的中位数是 2 ，[8,4,3,5,1] 的中位数是 4 。</li>
</ul>
</li>
<li>子数组是数组中的一个连续部分。<br><strong>示例1：</strong><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：nums = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>], k = <span class="number">4</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：中位数等于 <span class="number">4</span> 的子数组有：[<span class="number">4</span>]、[<span class="number">4</span>,<span class="number">5</span>] 和 [<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>] 。</span><br></pre></td></tr></table></figure>
<strong>提示：</strong></li>
<li>n &#x3D;&#x3D; nums.length</li>
<li>1 &lt;&#x3D; n &lt;&#x3D; 10^5</li>
<li>1 &lt;&#x3D; nums[i], k &lt;&#x3D; n</li>
<li>nums 中的整数互不相同<span id="more"></span></li>
</ul>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>本题要求中位数为k的子数组，那么子数组一定包含k，所有可以k为分割点将数组nums分成左右两部分，假设k所在的下标为index，那么子数组的数目为(index + 1) * (nums.length - index + 1)。<br><img data-src="/2023/03/16/2488-%E7%BB%9F%E8%AE%A1%E4%B8%AD%E4%BD%8D%E6%95%B0%E4%B8%BAK%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/1.png" alt="子数组图解"><br>当只考虑左边，子数组有{k},{6,k}…{2,…6,k},{1,2,…6,k}共index + 1个，右边也一样，{7}…{7,…n}共(nums.length - index)个，不用右边的或则在右边挑一个与左边配合则是一个子数组，那么子数组的个数就是(index + 1) * (nums.length - index + 1)。<br>我们只需要将所有子数组都判定一次，是否以k为中位数即可，若k为中位数，那么大于k的数目等于小于k的数目，所以我们只需要判断子数组中有多少个数大于k，有多少个小于k。（题目说明当为偶数的时候中间靠左的为中位数，也就是说大于k的数目可以比小于k的数目多1）<br>最简单的是，两层循环，外层循环遍历k的右边，内层循环遍历k的左边，只要当大于k的数目减去小于k的数目等于0或者1时，则为符合题意的子数组。很遗憾的是，最坏的情况下，即k的左右两边数目相等的时候，时间复杂度来到了O(n^2),在n&#x3D;10^5时会超出时间限制。<br>那么，常用的处理方法是将任意一边的情况存进哈希表，遍历另外一边，每次判断哈希表中是否存在满足题意的情况，这样时间复杂度无论k在哪里都是O(n)。</p>
<h1 id="代码-O-n"><a href="#代码-O-n" class="headerlink" title="代码 O(n)"></a>代码 O(n)</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countSubarrays</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">//储存大于k（小于k）的个数</span></span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//找到k的位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == k)&#123;</span><br><span class="line">                index = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//当d&gt;0 d则为大于k的个数，d=0, 大于k的个数与小于k的个数相等，d&lt;0 |d|则为小于k的个数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//&#123;k&#125; 自然是符合题目的子数组</span></span><br><span class="line">        map.put(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//遍历左边</span></span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//大于k d加1， 小于k d-1</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; nums[index])&#123;</span><br><span class="line">                d++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                d--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//并且把每个情况存进哈希表</span></span><br><span class="line">            map.put(d, map.getOrDefault(d, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        d = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//不取右边任何数，符合的个数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> map.getOrDefault(<span class="number">0</span>, <span class="number">0</span>) + map.getOrDefault(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(i = index + <span class="number">1</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; nums[index])&#123;</span><br><span class="line">                d++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                d--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当左右两边大于k个数减去小于k的个数的差为0或则1的时候符合题意</span></span><br><span class="line">            res += map.getOrDefault(<span class="number">0</span> - d, <span class="number">0</span>) + map.getOrDefault(<span class="number">1</span> - d, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode每日一题</category>
      </categories>
      <tags>
        <tag>LeetCode每日一题</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
</search>
